# 0125_homework



## 1. Built-in 함수와 메서드

```python
L = [4, 6, 2, 1, 3]
L.sort()
print(L) # => [1, 2, 3, 4, 6]
```

`.sort()`는 기존의 리스트를 직접 수정하여 오름차순으로 정렬해주는 메소드이다.

```python
L = [4, 6, 2, 1, 3]
print(sorted(L)) # => [1, 2, 3, 4, 6]
print(L) # => [4, 6, 2, 1, 3]
```

그에 반해 sorted()는 괄호 안에 인자로 넣어준 값을 오름차순 정렬시켜 반환하지만 원본값은 유지되는 내장 함수이다.

## 2. .extend()와 .append()

```python
L = [1, 2, 3]
L.append(4)
L.append(5)
print(L) # => [1, 2, 3, 4, 5]

L = [1, 2, 3]
L.append('uno')
print(L) # => [1, 2, 3, 'uno']
```

`.append()`는 1개의 인자를 전달 받아 리스트의 가장 마지막에 원소를 추가해주는 메소드이다.

```python
L = [1, 2, 3]
L.extend([4, 5])
print(L) # => [1, 2, 3, 4, 5]

L = [1, 2, 3]
L.extend('uno')
print(L) # => [1, 2, 3, 'u', 'n', 'o']
```

`.extend()`는 1개의 iterable을 전달 받아 항목 하나씩 리스트 마지막에 추가해준다.

## 3. 복사가 잘 된 건가?

```python
a = [1, 2, 3, 4, 5]
b = a

a[2] = 5

print(a) # => [1, 2, 5, 4, 5]
print(b) # => [1, 2, 5, 4, 5]
print(id(a) == id(b)) # => True
```

둘의 주소값이 동일하다. 즉 a의 값이 변경된다면 b도 같이, b가 변경된다면 a도 같이 변경됨을 의미한다. b는 a 값만 복사된 독립된 변수가 아니라, a로 바로가기 값 정도라고 생각하면 된다.

이를 원하지 않을 시,  리스트 슬라이싱을 통해 shallow copy를 하여 구분되는 주소값을 가진 두 객체를 가질 수 있다. 그러나 2차원 배열의 리스트,  mutable 객체 안에 mutable 객체인 경우 inner list 끼리 같은 주소를 바라보고 있으므로 `import copy`를 통해 `copy.deepcopy()`로 내부 객체들까지 모두 새롭게 복사할 수 있다.